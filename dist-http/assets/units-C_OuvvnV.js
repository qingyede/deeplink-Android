var q=Object.defineProperty;var $=n=>{throw TypeError(n)};var j=(n,t,i)=>t in n?q(n,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):n[t]=i;var T=(n,t,i)=>j(n,typeof t!="symbol"?t+"":t,i),A=(n,t,i)=>t.has(n)||$("Cannot "+i);var s=(n,t,i)=>(A(n,t,"read from private field"),i?i.call(n):t.get(n)),F=(n,t,i)=>t.has(n)?$("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(n):t.set(n,i),y=(n,t,i,e)=>(A(n,t,"write to private field"),e?e.call(n,i):t.set(n,i),i),u=(n,t,i)=>(A(n,t,"access private method"),i);import{n as D,d as G,b as w,a as b,c as z,k as H,t as J,g as K,u as L,r as k}from"./maths-Byej6qXm.js";const Q=BigInt(-1),m=BigInt(0),I=BigInt(1),W=BigInt(5),x={};let N="0000";for(;N.length<80;)N+=N;function v(n){let t=N;for(;t.length<n;)t+=t;return BigInt("1"+t.substring(0,n))}function B(n,t,i){const e=BigInt(t.width);if(t.signed){const r=I<<e-I;b(i==null||n>=-r&&n<r,"overflow","NUMERIC_FAULT",{operation:i,fault:"overflow",value:n}),n>m?n=L(k(n,e),e):n=-L(k(-n,e),e)}else{const r=I<<e;b(i==null||n>=0&&n<r,"overflow","NUMERIC_FAULT",{operation:i,fault:"overflow",value:n}),n=(n%r+r)%r&r-I}return n}function C(n){typeof n=="number"&&(n=`fixed128x${n}`);let t=!0,i=128,e=18;if(typeof n=="string"){if(n!=="fixed")if(n==="ufixed")t=!1;else{const a=n.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);w(a,"invalid fixed format","format",n),t=a[1]!=="u",i=parseInt(a[2]),e=parseInt(a[3])}}else if(n){const a=n,h=(d,S,Z)=>a[d]==null?Z:(w(typeof a[d]===S,"invalid fixed format ("+d+" not "+S+")","format."+d,a[d]),a[d]);t=h("signed","boolean",t),i=h("width","number",i),e=h("decimals","number",e)}w(i%8===0,"invalid FixedNumber width (not byte aligned)","format.width",i),w(e<=80,"invalid FixedNumber decimals (too large)","format.decimals",e);const r=(t?"":"u")+"fixed"+String(i)+"x"+String(e);return{signed:t,width:i,decimals:e,name:r}}function X(n,t){let i="";n<m&&(i="-",n*=Q);let e=n.toString();if(t===0)return i+e;for(;e.length<=t;)e=N+e;const r=e.length-t;for(e=e.substring(0,r)+"."+e.substring(r);e[0]==="0"&&e[1]!==".";)e=e.substring(1);for(;e[e.length-1]==="0"&&e[e.length-2]!==".";)e=e.substring(0,e.length-1);return i+e}var c,l,f,o,U,g,M,R,V,_;const p=class p{constructor(t,i,e){F(this,o);T(this,"format");F(this,c);F(this,l);F(this,f);T(this,"_value");D(t,x,"FixedNumber"),y(this,l,i),y(this,c,e);const r=X(i,e.decimals);G(this,{format:e.name,_value:r}),y(this,f,v(e.decimals))}get signed(){return s(this,c).signed}get width(){return s(this,c).width}get decimals(){return s(this,c).decimals}get value(){return s(this,l)}addUnsafe(t){return u(this,o,M).call(this,t)}add(t){return u(this,o,M).call(this,t,"add")}subUnsafe(t){return u(this,o,R).call(this,t)}sub(t){return u(this,o,R).call(this,t,"sub")}mulUnsafe(t){return u(this,o,V).call(this,t)}mul(t){return u(this,o,V).call(this,t,"mul")}mulSignal(t){u(this,o,U).call(this,t);const i=s(this,l)*s(t,l);return b(i%s(this,f)===m,"precision lost during signalling mul","NUMERIC_FAULT",{operation:"mulSignal",fault:"underflow",value:this}),u(this,o,g).call(this,i/s(this,f),"mulSignal")}divUnsafe(t){return u(this,o,_).call(this,t)}div(t){return u(this,o,_).call(this,t,"div")}divSignal(t){b(s(t,l)!==m,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),u(this,o,U).call(this,t);const i=s(this,l)*s(this,f);return b(i%s(t,l)===m,"precision lost during signalling div","NUMERIC_FAULT",{operation:"divSignal",fault:"underflow",value:this}),u(this,o,g).call(this,i/s(t,l),"divSignal")}cmp(t){let i=this.value,e=t.value;const r=this.decimals-t.decimals;return r>0?e*=v(r):r<0&&(i*=v(-r)),i<e?-1:i>e?1:0}eq(t){return this.cmp(t)===0}lt(t){return this.cmp(t)<0}lte(t){return this.cmp(t)<=0}gt(t){return this.cmp(t)>0}gte(t){return this.cmp(t)>=0}floor(){let t=s(this,l);return s(this,l)<m&&(t-=s(this,f)-I),t=s(this,l)/s(this,f)*s(this,f),u(this,o,g).call(this,t,"floor")}ceiling(){let t=s(this,l);return s(this,l)>m&&(t+=s(this,f)-I),t=s(this,l)/s(this,f)*s(this,f),u(this,o,g).call(this,t,"ceiling")}round(t){if(t==null&&(t=0),t>=this.decimals)return this;const i=this.decimals-t,e=W*v(i-1);let r=this.value+e;const a=v(i);return r=r/a*a,B(r,s(this,c),"round"),new p(x,r,s(this,c))}isZero(){return s(this,l)===m}isNegative(){return s(this,l)<m}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return p.fromString(this.toString(),t)}static fromValue(t,i,e){const r=i==null?0:z(i),a=C(e);let h=H(t,"value");const d=r-a.decimals;if(d>0){const S=v(d);b(h%S===m,"value loses precision for format","NUMERIC_FAULT",{operation:"fromValue",fault:"underflow",value:t}),h/=S}else d<0&&(h*=v(-d));return B(h,a,"fromValue"),new p(x,h,a)}static fromString(t,i){const e=t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);w(e&&e[2].length+e[3].length>0,"invalid FixedNumber string value","value",t);const r=C(i);let a=e[2]||"0",h=e[3]||"";for(;h.length<r.decimals;)h+=N;b(h.substring(r.decimals).match(/^0*$/),"too many decimals for format","NUMERIC_FAULT",{operation:"fromString",fault:"underflow",value:t}),h=h.substring(0,r.decimals);const d=BigInt(e[1]+a+h);return B(d,r,"fromString"),new p(x,d,r)}static fromBytes(t,i){let e=J(K(t,"value"));const r=C(i);return r.signed&&(e=L(e,r.width)),B(e,r,"fromBytes"),new p(x,e,r)}};c=new WeakMap,l=new WeakMap,f=new WeakMap,o=new WeakSet,U=function(t){w(this.format===t.format,"incompatible format; use fixedNumber.toFormat","other",t)},g=function(t,i){return t=B(t,s(this,c),i),new p(x,t,s(this,c))},M=function(t,i){return u(this,o,U).call(this,t),u(this,o,g).call(this,s(this,l)+s(t,l),i)},R=function(t,i){return u(this,o,U).call(this,t),u(this,o,g).call(this,s(this,l)-s(t,l),i)},V=function(t,i){return u(this,o,U).call(this,t),u(this,o,g).call(this,s(this,l)*s(t,l)/s(this,f),i)},_=function(t,i){return b(s(t,l)!==m,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),u(this,o,U).call(this,t),u(this,o,g).call(this,s(this,l)*s(this,f)/s(t,l),i)};let E=p;const P=["wei","kwei","mwei","gwei","szabo","finney","ether"];function Y(n,t){let i=18;if(typeof t=="string"){const e=P.indexOf(t);w(e>=0,"invalid unit","unit",t),i=3*e}else t!=null&&(i=z(t,"unit"));return E.fromValue(n,i,{decimals:i,width:512}).toString()}function O(n,t){w(typeof n=="string","value must be a string","value",n);let i=18;if(typeof t=="string"){const e=P.indexOf(t);w(e>=0,"invalid unit","unit",t),i=3*e}else t!=null&&(i=z(t,"unit"));return E.fromString(n,{decimals:i,width:512}).value}function et(n){return Y(n,18)}function nt(n){return O(n,18)}export{Y as a,nt as b,et as f,O as p};
